<script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
<script type="text/javascript">
  // GitHub Excel URL used by the app (single source of truth)
  const EXCEL_URL = "https://raw.githubusercontent.com/Harishbose/Voice-of-Customer/main/latest.xlsx";
</script><!-- Setting up the HTML structure with necessary CDN imports -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CX - Voice of Customer Dashboard</title>
  <!-- Including Tailwind CSS for styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Including necessary JavaScript libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chrono-node/1.3.11/chrono.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.12.7/Recharts.min.js"></script>
  <style>
    body { font-family: 'Roboto', sans-serif; background-color: #f3f4f6; }
    .kpi-card { transition: transform 0.2s; }
    .kpi-card:hover { transform: scale(1.05); }
    .filter-drawer { transition: width 0.3s; }
    .word-cloud {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      max-height: 280px;
      overflow: hidden;
      padding: 10px;
      box-sizing: border-box;
    }
    .word-cloud span {
      padding: 5px 10px;
      border-radius: 12px;
      white-space: nowrap;
      line-height: 1.2;
    }
    .comment-card {
      background-color: #f9fafb;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      border: 1px solid #e5e7eb;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .comment-header {
      color: #3b82f6;
    }
    .comment-details {
      font-size: 0.85rem;
      color: #6b7280;
    }
    .bar-label {
      fill: #000;
      font-size: 12px;
      font-weight: bold;
      text-anchor: middle;
      paint-order: stroke;
      stroke: #fff;
      stroke-width: 2px;
    }
    .heatmap-card {
      background-color: #ffffff;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .heatmap-cell {
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      padding: 8px;
      text-align: center;
      font-size: 0.9rem;
      min-width: 60px;
      cursor: pointer; /* Add cursor pointer for interactivity */
    }
    .chart-title {
      color: #000000;
      font-size: 1.25rem;
      font-weight: bold;
      margin-bottom: 16px;
    }
    .filter-search {
      width: 100%;
      padding: 8px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      margin-bottom: 8px;
    }
    .filter-options {
      max-height: 160px;
      overflow-y: auto;
      padding-right: 8px;
    }
    /* Custom style for X-axis labels */
    .custom-x-axis-label {
      font-size: 12px;
      fill: #333;
      text-anchor: middle;
      white-space: pre-wrap;
    }
    /* Insight card hover effect */
    .insight-card {
      transition: box-shadow 0.2s;
    }
    .insight-card:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Rendering the React application -->
  <script type="text/babel">
    // Defining the main React component
    const { useState, useEffect } = React;
    const {
      BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
      PieChart, Pie, Cell, LineChart, Line, LabelList
    } = Recharts;

    // Defining color palette
    const COLORS = {
      POSITIVE: '#10b981',
      NEGATIVE: '#ef4444',
      NEUTRAL: '#f59e0b',
      POSITIVE_LIGHT: '#2dd4bf',
      NEGATIVE_LIGHT: '#f87171',
      NEUTRAL_LIGHT: '#facc15',
      NONE: '#d1d5db'
    };

    // Defining emotion list
    const EMOTIONS = [
      { name: 'Satisfaction', color: '#10b981' },
      { name: 'Neutral', color: '#f59e0b' },
      { name: 'Appreciation', color: '#2dd4bf' },
      { name: 'Happy', color: '#34d399' },
      { name: 'Gratitude', color: '#6ee7b7' },
      { name: 'Frustration', color: '#ef4444' },
      { name: 'Disappointment', color: '#f87171' },
      { name: 'Anger', color: '#dc2626' },
      { name: 'Joy', color: '#22c55e' },
      { name: 'Trust', color: '#059669' },
      { name: 'Confusion', color: '#d97706' },
      { name: 'Sadness', color: '#b91c1c' }
    ];

    // Main Dashboard component
    function Dashboard() {
      const [data, setData] = useState([]);
      const [filters, setFilters] = useState({
        businessName: 'Metro',
        zone: [],
        state: [],
        city: [],
        storeCode: [],
        mallHS: [],
        sentiment: [],
        financialYear: ['FY2025-2026'],
        quarter: [],
        month: [],
        ImprovementCategory: []
      });
      const [showFilters, setShowFilters] = useState(true);
      const [filterSearch, setFilterSearch] = useState({});
      const [lowestZoneInsight, setLowestZoneInsight] = useState({
        zone: 'N/A',
        avgRating: 'N/A',
        reason: 'No data available'
      });

      // Loading and processing data (fetch Excel from GitHub and convert to CSV)
      useEffect(() => {
        (async () => {
          try {
            const resp = await fetch(EXCEL_URL);
            if (!resp.ok) throw new Error('Failed to fetch Excel file');
            const buffer = await resp.arrayBuffer();
            const workbook = XLSX.read(new Uint8Array(buffer), { type: 'array' });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            const csv = XLSX.utils.sheet_to_csv(worksheet, { header: 1 });

            Papa.parse(csv, {
              header: true,
              skipEmptyLines: true,
              dynamicTyping: false,
              transformHeader: header => header.trim().replace(/^"|"$/g, ''),
              transform: (value, header) => (value || '').toString().trim().replace(/^"|"$/g, ''),
              complete: (results) => {
                const cleanedData = processAndCleanData(results.data);
                setData(cleanedData);
              },
              error: (err) => console.error(err)
            });
          } catch (err) {
            console.error('Error loading Excel:', err);
          }
        })();
      }, []);

      // Processing and cleaning data
      const processAndCleanData = (rawData) => {
        const brandNormalization = {
          'CROCS': 'Crocs',
          'Crocs': 'Crocs',
          'crocs': 'Crocs',
          'FitFlop': 'Fitflop',
          'Fitflop': 'Fitflop'
        };

        return rawData
          .filter(row => row["Customer Response"] && row["Sentiment"])
          .map(row => ({
            ...row,
            "Business Name": brandNormalization[row["Business Name"]] || row["Business Name"],
            "Customer Rating": parseInt(row["Customer Rating"]) || 0,
            "Comment Date_NEW": chrono.parseDate(row["Comment Date_NEW"]) || new Date(),
            ImprovementCategory: classifyImprovementCategory(row["Customer Response"]),
            Emotion: detectEmotion(row["Customer Response"])
          }))
          .filter(row => row["Customer Rating"] >= 1 && row["Customer Rating"] <= 5);
      };

      // Classifying improvement categories with expanded keywords and phrases
      const classifyImprovementCategory = (response) => {
        const text = response.toLowerCase();

        // Define categories with expanded keywords and phrases
        const categories = [
          {
			name: 'Store Experience',
			keywords: ['staff', 'service', 'salesman', 'salesperson', 'experience', 'assistance', 'interaction','customer service', 'in-store', 'store environment', 'ambiance', 'atmosphere', 'cleanliness','tidy', 'organized', 'helpful', 'friendly', 'hospitality', 'welcoming','behaviour', 'behavior', 'attitude', 'rude', 'polite', 'courteous', 'professionalism','billing', 'payment', 'cashier', 'invoice', 'charged', 'billing issue', 'overcharge','wait', 'queue', 'delay', 'long queue', 'waiting time'],
			phrases: ['great service', 'poor service', 'excellent staff', 'helpful team', 'store was clean','bad experience', 'pleasant visit', 'unpleasant visit','rude staff', 'bad attitude', 'polite staff', 'unprofessional behavior','wrong billing', 'payment failed', 'billing mistake', 'double charged','long wait', 'waiting in line', 'slow billing', 'queue was long']
		  },
          {
            name: 'Product Quality',
            keywords: ['quality', 'material', 'product', 'durability', 'defect', 'faulty', 'item', 'merchandise', 'goods', 'performance', 'reliability', 'broken', 'damaged', 'substandard', 'premium', 'high quality', 'low quality'],
            phrases: ['poor quality', 'high quality', 'defective product', 'product broke', 'item was damaged', 'good material', 'bad material']
          },
          {
            name: 'Inventory Management',
            keywords: ['collection', 'variety', 'size', 'available', 'stock', 'availability', 'selection', 'range', 'inventory', 'out of stock', 'not in stock', 'limited choice', 'options', 'assortment', 'shortage', 'unavailable'],
            phrases: ['out of stock', 'not available', 'limited variety', 'more sizes needed', 'great selection', 'poor selection', 'no stock']
          },
          {
            name: 'Pricing & Discounts',
            keywords: ['price', 'cost', 'expensive', 'discount', 'deal', 'value', 'pricing', 'affordable', 'overpriced', 'cheap', 'budget', 'sale', 'offer', 'bargain', 'costly', 'price tag', 'value for money'],
            phrases: ['too expensive', 'great deal', 'no discount', 'overpriced item', 'good value', 'affordable price', 'price was high']
          },
          {
            name: 'Return & Refund Policies',
            keywords: ['return', 'exchange', 'refund', 'policy', 'returnable', 'warranty', 'replacement', 'return process', 'hassle', 'non-returnable', 'refund issue', 'exchange problem', 'return denied'],
            phrases: ['easy return', 'difficult return', 'no refund', 'hassle-free exchange', 'return was rejected', 'refund took long', 'exchange not allowed']
          },
          {
            name: 'Customer Support',
            keywords: ['support', 'help', 'assistance', 'responsive', 'query', 'resolution', 'customer care', 'helpline', 'support team', 'follow-up', 'complaint', 'issue resolution', 'unresponsive', 'no help', 'quick response', 'slow response'],
            phrases: ['great support', 'poor support', 'no response', 'quick resolution', 'unhelpful customer care', 'issue not resolved', 'helpful helpline']
          },
          {
            name: 'Promotions & Offers',
            keywords: ['promotion', 'offer', 'loyalty', 'deal', 'coupon', 'reward', 'discount code', 'special offer', 'promo', 'voucher', 'membership', 'benefits', 'exclusive deal', 'no offer', 'missed promotion'],
            phrases: ['great offer', 'no promotion', 'used coupon', 'loyalty reward', 'special deal', 'promo code issue', 'no discount applied']
          }
        ];

        // Match phrases first for higher context accuracy
        for (const category of categories) {
          for (const phrase of category.phrases) {
            if (text.includes(phrase)) {
              return category.name;
            }
          }
        }

        // Match single keywords
        let bestCategory = null;
        let maxMatches = 0;
        for (const category of categories) {
          const matches = category.keywords.filter(keyword => text.includes(keyword)).length;
          if (matches > maxMatches) {
            maxMatches = matches;
            bestCategory = category.name;
          }
        }

        // Default to Store Experience if no match
        return bestCategory || 'Store Experience';
      };

      // Detecting emotion
      const detectEmotion = (response) => {
        const text = response.toLowerCase();
        if (text) {
          if (text.includes('great') || text.includes('excellent') || text.includes('awesome') || text.includes('superb')) {
            return 'Satisfaction';
          } else if (text.includes('good') || text.includes('nice') || text.includes('pleasant')) {
            return 'Happy';
          } else if (text.includes('thank') || text.includes('grateful') || text.includes('appreciate')) {
            return 'Gratitude';
          } else if (text.includes('worst') || text.includes('terrible') || text.includes('pathetic')) {
            return 'Disappointment';
          } else if (text.includes('rude') || text.includes('unprofessional') || text.includes('awful')) {
            return 'Frustration';
          } else if (text.includes('disappointed') || text.includes('poor') || text.includes('bad')) {
            return 'Disappointment';
          } else if (text.includes('love') || text.includes('loved') || text.includes('amazing')) {
            return 'Joy';
          } else if (text.includes('trust') || text.includes('reliable')) {
            return 'Trust';
          } else if (text.includes('confused') || text.includes('uncertain')) {
            return 'Confusion';
          } else if (text.includes('sad') || text.includes('regret')) {
            return 'Sadness';
          } else if (text.includes('angry') || text.includes('upset')) {
            return 'Anger';
          } else {
            return 'Neutral';
          }
        } else {
          return 'Unknown';
        }
      };

      // Applying filters
      const filteredData = data.filter(row => {
        return (
              (!filters.businessName || row["Business Name"] === filters.businessName) &&
              (filters.zone.length === 0 || filters.zone.includes(row.Zone)) &&
              (filters.state.length === 0 || filters.state.includes(row.State)) &&
              (filters.city.length === 0 || filters.city.includes(row.City)) &&
              (filters.storeCode.length === 0 || filters.storeCode.includes(row["Store Code"])) &&
              (filters.mallHS.length === 0 || filters.mallHS.includes(row["Mall/HS"])) &&
              (filters.sentiment.length === 0 || filters.sentiment.includes(row.Sentiment)) &&
              (filters.financialYear.length === 0 || filters.financialYear.includes(row.FY)) &&
              (filters.quarter.length === 0 || filters.quarter.includes(row.Quarter)) &&
              (filters.month.length === 0 || filters.month.includes(row.Month)) &&
              (filters.ImprovementCategory.length === 0 || filters.ImprovementCategory.includes(row.ImprovementCategory))
            );
      });

      // Compute lowest-rated zone insight
      useEffect(() => {
        if (filteredData.length === 0) {
          setLowestZoneInsight({
            zone: 'N/A',
            avgRating: 'N/A',
            reason: 'No data available'
          });
          return;
        }

        // Calculate average rating per zone
        const zoneRatings = {};
        filteredData.forEach(row => {
          const zone = row.Zone;
          if (!zoneRatings[zone]) {
            zoneRatings[zone] = { total: 0, count: 0 };
          }
          zoneRatings[zone].total += row["Customer Rating"];
          zoneRatings[zone].count += 1;
        });

        // Get zones to consider
        const zonesToConsider = filters.zone.length > 0
          ? filters.zone
          : Object.keys(zoneRatings);

        if (zonesToConsider.length === 0) {
          setLowestZoneInsight({
            zone: 'N/A',
            avgRating: 'N/A',
            reason: 'No zones available'
          });
          return;
        }

        // Find lowest-rated zone
        let lowestZone = null;
        let lowestAvg = Infinity;
        zonesToConsider.forEach(zone => {
          if (zoneRatings[zone]) {
            const avg = zoneRatings[zone].total / zoneRatings[zone].count;
            if (avg < lowestAvg) {
              lowestAvg = avg;
              lowestZone = zone;
            }
          }
        });

        if (!lowestZone) {
          setLowestZoneInsight({
            zone: 'N/A',
            avgRating: 'N/A',
            reason: 'No valid ratings'
          });
          return;
        }

        // Calculate reason based on negative reviews
        const negativeReviews = filteredData
          .filter(row => row.Zone === lowestZone && row.Sentiment === 'NEGATIVE');
        const categoryCounts = negativeReviews.reduce((acc, row) => {
          const cat = row.ImprovementCategory;
          acc[cat] = (acc[cat] || 0) + 1;
          return acc;
        }, {});
        const topCategory = Object.entries(categoryCounts)
          .sort((a, b) => b[1] - a[1])[0];
        const reason = topCategory
          ? `driven by negative reviews on ${topCategory[0].toLowerCase()}`
          : 'driven by mixed feedback';

        setLowestZoneInsight({
          zone: lowestZone,
          avgRating: lowestAvg.toFixed(1),
          reason
        });
      }, [filters.zone, filteredData]);

      // Getting unique filter options with dependencies
      const getUniqueOptions = (key) => {
        let filteredRows = data;

        // Apply Business Name filter
        if (filters.businessName && key !== 'Business Name') {
          filteredRows = filteredRows.filter(row => row["Business Name"] === filters.businessName);
        }

        // Apply Zone filter for State, City, Store Code, ImprovementCategory
        if (key !== 'Zone' && key !== 'Business Name' && filters.zone.length > 0) {
          filteredRows = filteredRows.filter(row => filters.zone.includes(row.Zone));
        }

        // Apply State filter for City, Store Code, ImprovementCategory
        if (key !== 'Zone' && key !== 'State' && key !== 'Business Name' && filters.state.length > 0) {
          filteredRows = filteredRows.filter(row => filters.state.includes(row.State));
        }

        // Apply City filter for Store Code, ImprovementCategory
        if (key === 'Store Code' || key === 'ImprovementCategory' && filters.city.length > 0) {
          filteredRows = filteredRows.filter(row => filters.city.includes(row.City));
        }

        return [...new Set(filteredRows.map(row => row[key]).filter(val => val))].sort();
      };

      // Calculating KPIs
      const totalReviews = filteredData.length;
      const negativeReviews = filteredData.filter(row => row.Sentiment === 'NEGATIVE').length;
      const percentNegative = totalReviews > 0 ? ((negativeReviews / totalReviews) * 100).toFixed(1) : 0;
      const storeRatings = {};
      filteredData.forEach(row => {
        const store = row["Store Code"];
        if (!storeRatings[store]) {
          storeRatings[store] = { total: 0, count: 0 };
        }
        storeRatings[store].total += row["Customer Rating"];
        storeRatings[store].count += 1;
      });
      const storeAvgRatings = Object.entries(storeRatings).map(([store, { total, count }]) => ({
        store,
        avg: total / count
      }));
      const bestStore = storeAvgRatings.sort((a, b) => b.avg - a.avg)[0] || { store: 'N/A', avg: 0 };
      const worstStore = storeAvgRatings.sort((a, b) => a.avg - b.avg)[0] || { store: 'N/A', avg: 0 };

      // Preparing data for charts
      const sentimentCounts = filteredData.reduce((acc, row) => {
        acc[row.Sentiment] = (acc[row.Sentiment] || 0) + 1;
        return acc;
      }, { POSITIVE: 0, NEGATIVE: 0, NEUTRAL: 0 });

      const categoryCounts = filteredData.reduce((acc, row) => {
        const cat = row.ImprovementCategory;
        acc[cat] = (acc[cat] || 0) + 1;
        return acc;
      }, {});
      const categoryData = Object.entries(categoryCounts)
        .map(([name, value]) => ({ name, value }))
        .sort((a, b) => b.value - a.value);

      const maxCategoryValue = categoryData.length > 0 ? Math.max(...categoryData.map(d => d.value)) : 0;
      const yAxisMax = Object.keys(filters).every(key => 
        Array.isArray(filters[key]) ? filters[key].length === 0 : !filters[key]
      ) ? 5000 : maxCategoryValue + 10;

      const emotionCounts = filteredData.reduce((acc, row) => {
        acc[row.Emotion] = (acc[row.Emotion] || 0) + 1;
        return acc;
      }, {});
      const maxCount = Math.max(...Object.values(emotionCounts), 1);
      const minFontSize = 12;
      const maxFontSize = 24;
      const emotionData = Object.entries(emotionCounts).map(([name, count]) => ({
        name,
        count,
        color: EMOTIONS.find(e => e.name === name)?.color || '#d1d5db',
        fontSize: Math.min(maxFontSize, Math.max(minFontSize, minFontSize + (count / maxCount) * (maxFontSize - minFontSize)))
      }));

      const sentimentByZone = {};
      filteredData.forEach(row => {
        const zone = row.Zone;
        if (!sentimentByZone[zone]) {
          sentimentByZone[zone] = { POSITIVE: 0, NEGATIVE: 0, NEUTRAL: 0 };
        }
        sentimentByZone[zone][row.Sentiment]++;
      });
      const zoneData = Object.entries(sentimentByZone).map(([zone, counts]) => ({
        zone,
        ...counts
      }));

      const sentimentTrend = {};
      filteredData.forEach(row => {
        const month = row.Month;
        if (!sentimentTrend[month]) {
          sentimentTrend[month] = { POSITIVE: 0, NEGATIVE: 0, NEUTRAL: 0 };
        }
        sentimentTrend[month][row.Sentiment]++;
      });
      const trendData = Object.entries(sentimentTrend).map(([month, counts]) => ({
        month,
        ...counts
      }));

      const heatmapData = {};
      const topStores = Object.entries(
        filteredData.reduce((acc, row) => {
          acc[row["Store Code"]] = (acc[row["Store Code"]] || 0) + 1;
          return acc;
        }, {})
      )
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([store]) => store);

      topStores.forEach(store => {
        heatmapData[store] = {};
        filteredData
          .filter(row => row["Store Code"] === store)
          .forEach(row => {
            const cat = row.ImprovementCategory;
            if (!heatmapData[store][cat]) {
              heatmapData[store][cat] = { POSITIVE: 0, NEGATIVE: 0, NEUTRAL: 0 };
            }
            heatmapData[store][cat][row.Sentiment]++;
          });
      });

      const heatmapChartData = topStores.map(store => {
        const row = { store };
        Object.keys(categoryCounts).forEach(cat => {
          const sentiments = heatmapData[store][cat] || { POSITIVE: 0, NEGATIVE: 0, NEUTRAL: 0 };
          const total = sentiments.POSITIVE + sentiments.NEGATIVE + sentiments.NEUTRAL;
          if (total === 0) {
            row[cat] = { count: 0, sentiment: 'NONE' };
          } else {
            const maxSentiment = sentiments.POSITIVE >= sentiments.NEGATIVE && sentiments.POSITIVE >= sentiments.NEUTRAL
              ? 'POSITIVE'
              : sentiments.NEGATIVE >= sentiments.POSITIVE && sentiments.NEGATIVE >= sentiments.NEUTRAL
              ? 'NEGATIVE'
              : 'NEUTRAL';
            row[cat] = {
              count: total,
              sentiment: maxSentiment,
              percent: {
                POSITIVE: ((sentiments.POSITIVE / total) * 100).toFixed(1),
                NEGATIVE: ((sentiments.NEGATIVE / total) * 100).toFixed(1),
                NEUTRAL: ((sentiments.NEUTRAL / total) * 100).toFixed(1)
              },
              sample: filteredData.find(r => r["Store Code"] === store && r.ImprovementCategory === cat)?.["Customer Response"] || ''
            };
          }
        });
        return row;
      });

      // Calculate insights data
      const storeExpPercent = totalReviews > 0
        ? ((categoryCounts['Store Experience'] || 0) / totalReviews * 100).toFixed(1)
        : 0;

      const lowRatedStores = storeAvgRatings
        .filter(s => s.avg <= 3.6 && s.store !== 'N/A')
        .map(s => s.store)
        .slice(0, 2)
        .join(' & ') || 'None';

      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const recentPositive = filteredData.filter(row => 
        row.Sentiment === 'POSITIVE' && new Date(row["Comment Date_NEW"]) >= thirtyDaysAgo
      ).length;
      const priorPositive = filteredData.filter(row => 
        row.Sentiment === 'POSITIVE' && new Date(row["Comment Date_NEW"]) < thirtyDaysAgo
      ).length;
      const positiveGrowth = priorPositive > 0
        ? ((recentPositive - priorPositive) / priorPositive * 100).toFixed(1)
        : recentPositive > 0 ? 100 : 0;

      const cityReviewCounts = filteredData.reduce((acc, row) => {
        const city = row.City;
        acc[city] = (acc[city] || 0) + 1;
        return acc;
      }, {});
      const topCities = Object.entries(cityReviewCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2)
        .map(([city]) => city)
        .join(' & ') || 'None';

      const bestStoreInfo = bestStore.store !== 'N/A' 
        ? `${bestStore.store} (${bestStore.avg.toFixed(1)})` 
        : 'None';

      // Handling filter changes
      const handleFilterChange = (key, value) => {
        setFilters(prev => {
          let newFilters = { ...prev };

          if (key === 'businessName') {
            newFilters[key] = value;
            // Reset dependent filters
            newFilters.zone = [];
            newFilters.state = [];
            newFilters.city = [];
            newFilters.storeCode = [];
            newFilters.ImprovementCategory = [];
            return newFilters;
          }

          // Handle checkbox filters
          const newValues = prev[key].includes(value)
            ? prev[key].filter(v => v !== value)
            : [...prev[key], value];
          newFilters[key] = newValues;

          // Reset dependent filters based on the changed filter
          if (key === 'zone') {
            newFilters.state = [];
            newFilters.city = [];
            newFilters.storeCode = [];
            newFilters.ImprovementCategory = [];
          } else if (key === 'state') {
            newFilters.city = [];
            newFilters.storeCode = [];
            newFilters.ImprovementCategory = [];
          } else if (key === 'city') {
            newFilters.storeCode = [];
            newFilters.ImprovementCategory = [];
          }

          return newFilters;
        });
      };

      // Handle chart interactions
      const handlePieClick = (data) => {
        if (data && data.name) {
          handleFilterChange('sentiment', data.name);
        }
      };

      const handleBarClick = (data, chartType) => {
        if (data) {
          if (chartType === 'category' && data.name) {
            handleFilterChange('ImprovementCategory', data.name);
          } else if (chartType === 'zone' && data.zone) {
            handleFilterChange('zone', data.zone);
          }
        }
      };

      const handleHeatmapClick = (store, category) => {
        setFilters(prev => ({
          ...prev,
          storeCode: [store],
          ImprovementCategory: [category]
        }));
      };

      const resetFilters = () => {
        setFilters({
          businessName: 'Metro',
          zone: [],
          state: [],
          city: [],
          storeCode: [],
          mallHS: [],
          sentiment: [],
          financialYear: ['FY2025-2026'],
          quarter: [],
          month: [],
          ImprovementCategory: []
        });
        setFilterSearch({});
      };

      // Handle filter search
      const handleFilterSearch = (key, value) => {
        setFilterSearch(prev => ({ ...prev, [key]: value }));
      };

      // Get filtered options based on search
      const getFilteredOptions = (key, options) => {
        const search = filterSearch[key]?.toLowerCase() || '';
        return options.filter(opt => opt.toLowerCase().includes(search));
      };

      // Shortened category names for heatmap
      const shortenCategoryName = (cat) => {
        return cat === 'Store Experience' ? 'Store Exp' :
               cat === 'Inventory Management' ? 'Inv Mgmt' :
               cat === 'Customer Support' ? 'Cust Support' :
               cat === 'Pricing & Discounts' ? 'Price Disc' :
               cat === 'Staff Behaviour' ? 'Staff Behvr' :
               cat === 'Product Quality' ? 'Prod Qlty' :
               cat === 'Return & Refund Policies' ? 'Return Refund' :
               cat === 'Promotions & Offers' ? 'Promo Offers' :
               cat === 'Billing & Payment Issues' ? 'Billing Issue' :
               cat === 'Wait Time / Queue Management' ? 'Wait Queue' : cat;
      };

      // Format X-axis labels with specified short names and line breaks
      const formatXAxisLabel = (label) => {
        switch (label) {
          case 'Store Experience': return 'Store<br>Exp';
          case 'Product Quality': return 'Prod<br>Qlty';
          case 'Inventory Management': return 'Inv<br>Mgmt';
          case 'Pricing & Discounts': return 'Price<br>Disc';
          case 'Return & Refund Policies': return 'Return<br>Refund';
          case 'Customer Support': return 'Cust<br>Support';
          case 'Promotions & Offers': return 'Promo<br>Offers';
          case 'Billing & Payment Issues': return 'Billing<br>Issue';
          case 'Staff Behaviour': return 'Staff<br>Behvr';
          case 'Wait Time / Queue Management': return 'Wait<br>Queue';
          default: return label;
        }
      };

      // Custom tick component for X-axis
      const CustomXAxisTick = ({ x, y, payload }) => {
        const formattedLabel = formatXAxisLabel(payload.value);
        return (
          <g transform={`translate(${x},${y})`}>
            <text
              x={0}
              y={0}
              dy={16}
              className="custom-x-axis-label"
              textAnchor="middle"
              dangerouslySetInnerHTML={{ __html: formattedLabel.replace('<br>', '\n') }}
            />
          </g>
        );
      };

      // Rendering the dashboard
      return (
        <div className="container mx-auto p-4">
          {/* Toggling filter drawer */}
          <button
            className="bg-gray-800 text-white px-4 py-2 rounded mb-4"
            onClick={() => setShowFilters(!showFilters)}
          >
            {showFilters ? 'Hide Filters' : 'Show Filters'}
          </button>

          <div className="flex">
            {/* Filter Drawer */}
            {showFilters && (
              <div className="filter-drawer w-64 bg-white p-4 rounded shadow mr-4">
                <h2 className="text-lg font-bold mb-4">Filters</h2>
                <button
                  className="bg-red-500 text-white px-2 py-1 rounded mb-4"
                  onClick={resetFilters}
                >
                  Reset Filters
                </button>

                {/* Business Name Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Brand</h3>
                  <select
                    className="w-full p-2 border rounded"
                    value={filters.businessName}
                    onChange={(e) => handleFilterChange('businessName', e.target.value)}
                  >
                    {getUniqueOptions('Business Name').map(option => (
                      <option key={option} value={option}>{option}</option>
                    ))}
                  </select>
                </div>

                {/* Zone Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Zone</h3>
                  <input
                    type="text"
                    placeholder="Search Zone"
                    className="filter-search"
                    value={filterSearch.zone || ''}
                    onChange={(e) => handleFilterSearch('zone', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('zone', getUniqueOptions('Zone')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.zone.includes(option)}
                          onChange={() => handleFilterChange('zone', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* State Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">State</h3>
                  <input
                    type="text"
                    placeholder="Search State"
                    className="filter-search"
                    value={filterSearch.state || ''}
                    onChange={(e) => handleFilterSearch('state', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('state', getUniqueOptions('State')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.state.includes(option)}
                          onChange={() => handleFilterChange('state', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* City Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">City</h3>
                  <input
                    type="text"
                    placeholder="Search City"
                    className="filter-search"
                    value={filterSearch.city || ''}
                    onChange={(e) => handleFilterSearch('city', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('city', getUniqueOptions('City')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.city.includes(option)}
                          onChange={() => handleFilterChange('city', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Store Code Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Store Code</h3>
                  <input
                    type="text"
                    placeholder="Search Store Code"
                    className="filter-search"
                    value={filterSearch.storeCode || ''}
                    onChange={(e) => handleFilterSearch('storeCode', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('storeCode', getUniqueOptions('Store Code')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.storeCode.includes(option)}
                          onChange={() => handleFilterChange('storeCode', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Mall/HS Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Mall/HS</h3>
                  <input
                    type="text"
                    placeholder="Search Mall/HS"
                    className="filter-search"
                    value={filterSearch.mallHS || ''}
                    onChange={(e) => handleFilterSearch('mallHS', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('mallHS', getUniqueOptions('Mall/HS')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.mallHS.includes(option)}
                          onChange={() => handleFilterChange('mallHS', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Sentiment Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Sentiment</h3>
                  <input
                    type="text"
                    placeholder="Search Sentiment"
                    className="filter-search"
                    value={filterSearch.sentiment || ''}
                    onChange={(e) => handleFilterSearch('sentiment', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('sentiment', ['POSITIVE', 'NEGATIVE', 'NEUTRAL']).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.sentiment.includes(option)}
                          onChange={() => handleFilterChange('sentiment', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option.charAt(0) + option.slice(1).toLowerCase()}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Themes (ImprovementCategory) Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Themes</h3>
                  <input
                    type="text"
                    placeholder="Search Themes"
                    className="filter-search"
                    value={filterSearch.ImprovementCategory || ''}
                    onChange={(e) => handleFilterSearch('ImprovementCategory', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('ImprovementCategory', getUniqueOptions('ImprovementCategory')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.ImprovementCategory.includes(option)}
                          onChange={() => handleFilterChange('ImprovementCategory', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Financial Year Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Financial Year</h3>
                  <input
                    type="text"
                    placeholder="Search Financial Year"
                    className="filter-search"
                    value={filterSearch.financialYear || ''}
                    onChange={(e) => handleFilterSearch('financialYear', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('financialYear', getUniqueOptions('FY')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.financialYear.includes(option)}
                          onChange={() => handleFilterChange('financialYear', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Quarter Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Quarter</h3>
                  <input
                    type="text"
                    placeholder="Search Quarter"
                    className="filter-search"
                    value={filterSearch.quarter || ''}
                    onChange={(e) => handleFilterSearch('quarter', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('quarter', getUniqueOptions('Quarter')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.quarter.includes(option)}
                          onChange={() => handleFilterChange('quarter', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Month Filter */}
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Month</h3>
                  <input
                    type="text"
                    placeholder="Search Month"
                    className="filter-search"
                    value={filterSearch.month || ''}
                    onChange={(e) => handleFilterSearch('month', e.target.value)}
                  />
                  <div className="filter-options">
                    {getFilteredOptions('month', getUniqueOptions('Month')).map(option => (
                      <div key={option} className="flex items-center mb-1">
                        <input
                          type="checkbox"
                          checked={filters.month.includes(option)}
                          onChange={() => handleFilterChange('month', option)}
                          className="mr-2"
                        />
                        <label className="text-sm">{option}</label>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            <div className="flex-1">
              {/* Executive Snapshot KPIs */}
              <div className="grid grid-cols-4 gap-4 mb-8">
                <div className="kpi-card bg-gradient-to-r from-gray-200 to-gray-300 p-4 rounded shadow">
                  <h3 className="text-lg font-semibold">Total Reviews</h3>
                  <p className="text-2xl">{totalReviews}</p>
                </div>
                <div className="kpi-card bg-gradient-to-r from-red-200 to-red-300 p-4 rounded shadow">
                  <h3 className="text-lg font-semibold">% Negative</h3>
                  <p className="text-2xl">{percentNegative}%</p>
                </div>
                <div className="kpi-card bg-gradient-to-r from-green-200 to-green-300 p-4 rounded shadow">
                  <h3 className="text-lg font-semibold">Best Store</h3>
                  <p className="text-2xl">{bestStore.store} ({bestStore.avg.toFixed(1)})</p>
                </div>
                <div className="kpi-card bg-gradient-to-r from-yellow-200 to-yellow-300 p-4 rounded shadow">
                  <h3 className="text-lg font-semibold">Lowest Rated Store</h3>
                  <p className="text-2xl">{worstStore.store} ({worstStore.avg.toFixed(1)})</p>
                </div>
              </div>

              {/* Strategic Insights */}
              <div className="mb-8">
                <h2 className="text-xl font-bold mb-4">Strategic Insights</h2>
                <div className="grid grid-cols-2 lg:grid-cols-3 gap-4">
                  {/* Theme to Prioritize */}
                  <div className="insight-card bg-gray-100 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2">üìä</span>
                      <h3 className="text-lg font-bold text-gray-800">Store Experience Dominates</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      This was the most mentioned theme, appearing in {storeExpPercent}% of all customer feedback. It is the key driver of both praise and criticism.
                    </p>
                  </div>

                  {/* Zone Sentiment Dip */}
                  <div className="insight-card bg-red-50 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2 text-red-600">‚¨á</span>
                      <h3 className="text-lg font-bold text-gray-800">{lowestZoneInsight.zone} Sentiment Dip</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      Average rating dropped to {lowestZoneInsight.avgRating}, {lowestZoneInsight.reason}.
                    </p>
                  </div>

                  {/* Underperforming Stores */}
                  <div className="insight-card bg-yellow-50 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2">‚ö†</span>
                      <h3 className="text-lg font-bold text-gray-800">{lowRatedStores} Need Urgent Attention</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      These stores recorded the lowest ratings (‚â§3.6) and consistently receive negative sentiment.
                    </p>
                  </div>

                  {/* Positive Momentum */}
                  <div className="insight-card bg-green-50 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2 text-green-600">‚¨Ü</span>
                      <h3 className="text-lg font-bold text-gray-800">Uptick in Positive Feedback</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      Positive reviews increased by {positiveGrowth}% in the past 30 days, especially across the West Zone.
                    </p>
                  </div>

                  {/* High Review Volume Cities */}
                  <div className="insight-card bg-blue-50 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2">üìç</span>
                      <h3 className="text-lg font-bold text-gray-800">{topCities} in Spotlight</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      These cities saw the highest review volumes with mixed sentiment. Key areas for action.
                    </p>
                  </div>

                  {/* Best Store */}
                  <div className="insight-card bg-teal-50 p-4 rounded-lg shadow-sm">
                    <div className="flex items-center mb-2">
                      <span className="text-xl mr-2">üèÜ</span>
                      <h3 className="text-lg font-bold text-gray-800">Leading Store Performance</h3>
                    </div>
                    <p className="text-sm text-gray-600">
                      Store {bestStoreInfo} and its regional cluster lead on service ‚Äî potential model for scaling excellence.
                    </p>
                  </div>
                </div>
              </div>

              {/* Row 1: Key Drivers of Customer Feedback */}
              <div className="mb-8">
                <h2 className="chart-title">Key Drivers of Customer Feedback</h2>
                <ResponsiveContainer width="100%" height={400}>
                  <BarChart
                    data={categoryData}
                    margin={{ top: 20, right: 30, left: 20, bottom: 50 }}
                    onClick={(data) => handleBarClick(data.activePayload?.[0]?.payload, 'category')}
                  >
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis
                      dataKey="name"
                      tick={<CustomXAxisTick />}
                      interval={0}
                      height={60}
                    />
                    <YAxis domain={[0, yAxisMax]} />
                    <Tooltip />
                    <Bar dataKey="value" fill="#10b981">
                      {categoryData.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={COLORS.POSITIVE} />
                      ))}
                      <LabelList dataKey="value" position="top" className="bar-label" />
                    </Bar>
                  </BarChart>
                </ResponsiveContainer>
              </div>

              {/* Row 2: Emotion Word Cloud and Sentiment Breakdown */}
              <div className="grid grid-cols-2 gap-4 mb-8">
                <div>
                  <h2 className="chart-title">Emotion Word Cloud</h2>
                  <div className="word-cloud">
                    {emotionData.map(emotion => (
                      <span
                        key={emotion.name}
                        style={{
                          backgroundColor: emotion.color,
                          fontSize: `${emotion.fontSize}px`,
                          color: '#fff',
                          maxWidth: '150px',
                          overflow: 'hidden',
                          textOverflow: 'ellipsis'
                        }}
                      >
                        {emotion.name} ({emotion.count})
                      </span>
                    ))}
                  </div>
                </div>
                <div>
                  <h2 className="chart-title">Sentiment Breakdown</h2>
                  <ResponsiveContainer width="100%" height={300}>
                    <PieChart>
                      <Pie
                        data={Object.entries(sentimentCounts).map(([name, value]) => ({ name, value }))}
                        cx="50%"
                        cy="50%"
                        labelLine={true}
                        label={({ percent }) => `${(percent * 100).toFixed(1)}%`}
                        outerRadius={80}
                        fill="#8884d8"
                        dataKey="value"
                        onClick={handlePieClick}
                      >
                        {Object.entries(sentimentCounts).map((entry, index) => (
                          <Cell key={`cell-${index}`} fill={COLORS[entry[0]]} />
                        ))}
                      </Pie>
                      <Tooltip formatter={(value, name) => [value, name]} />
                      <Legend />
                    </PieChart>
                  </ResponsiveContainer>
                </div>
              </div>

              {/* Row 3: Sentiment Trend Over Time */}
              <div className="mb-8">
                <h2 className="chart-title">Sentiment Trend over Time</h2>
                <ResponsiveContainer width="100%" height={300}>
                  <LineChart data={trendData}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="month" tick={{ fontSize: 12 }} />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    <Line type="monotone" dataKey="POSITIVE" stroke={COLORS.POSITIVE} />
                    <Line type="monotone" dataKey="NEGATIVE" stroke={COLORS.NEGATIVE} />
                    <Line type="monotone" dataKey="NEUTRAL" stroke={COLORS.NEUTRAL} />
                  </LineChart>
                </ResponsiveContainer>
              </div>

              {/* Row 4: Heatmap and Sentiment by Zone */}
              <div className="grid grid-cols-2 gap-4 mb-8">
                <div className="heatmap-card">
                  <h2 className="chart-title">Store-wise Feedback Drivers Heatmap</h2>
                  <div className="overflow-x-auto">
                    <table className="w-full">
                      <thead>
                        <tr>
                          <th className="heatmap-cell font-semibold sticky left-0 bg-white z-10">Store</th>
                          {Object.keys(categoryCounts).map(cat => (
                            <th key={cat} className="heatmap-cell font-semibold">
                              {shortenCategoryName(cat)}
                            </th>
                          ))}
                        </tr>
                      </thead>
                      <tbody>
                        {heatmapChartData.map(row => (
                          <tr key={row.store}>
                            <td className="heatmap-cell sticky left-0 bg-white z-10">{row.store}</td>
                            {Object.keys(categoryCounts).map(cat => {
                              const cell = row[cat] || { count: 0, sentiment: 'NONE' };
                              const bgColor = COLORS[cell.sentiment];
                              const textColor = cell.sentiment === 'NONE' ? '#000' : '#fff';
                              const indicator = cell.sentiment === 'POSITIVE' ? '‚ô•' :
                                        cell.sentiment === 'NEGATIVE' ? '‚Üì' : 
                                        cell.sentiment === 'NEUTRAL' ? '‚Üî' : '';
                              return (
                                <td
                                  className="heatmap-cell"
                                  style={{ backgroundColor: bgColor, color: textColor }}
                                  key={`${row.store}-${cat}`}
                                  title={
                                    cell.count > 0
                                      ? `Count: ${cell.count}\nPositive: ${cell.percent.POSITIVE}%\nNegative: ${cell.percent.NEGATIVE}%\nSample: ${cell.sample}`
                                      : ''
                                  }
                                  onClick={() => cell.count > 0 && handleHeatmapClick(row.store, cat)}
                                >
                                  {cell.count > 0 ? `${cell.count} ${indicator}` : '-'}
                                </td>
                              );
                            })}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                  <div className="flex justify-end mt-4 space-x-4">
                    <div className="flex items-center">
                      <div className="w-4 h-4 bg-teal-500 mr-2"></div> Positive
                    </div>
                    <div className="flex items-center">
                      <div className="w-4 h-4 bg-red-600 mr-2"></div> Negative
                    </div>
                    <div className="flex items-center">
                      <div className="w-4 h-4 bg-yellow-500 mr-2"></div> Neutral
                    </div>
                    <div className="flex items-center">
                      <div className="w-4 h-4 bg-gray-300 mr-2"></div> None
                    </div>
                  </div>
                </div>
                <div>
                  <h2 className="chart-title">Sentiment by Zone</h2>
                  <ResponsiveContainer width="100%" height={300}>
                    <BarChart
                      data={zoneData}
                      onClick={(data) => handleBarClick(data.activePayload?.[0]?.payload, 'zone')}
                    >
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="zone" tick={{ fontSize: 12 }} />
                      <YAxis />
                      <Tooltip />
                      <Legend />
                      <Bar dataKey="POSITIVE" fill={COLORS.POSITIVE} />
                      <Bar dataKey="NEGATIVE" fill={COLORS.NEGATIVE} />
                      <Bar dataKey="NEUTRAL" fill={COLORS.NEUTRAL} />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              </div>

              {/* Row 5: Comments Viewer */}
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <h2 className="chart-title">Positive Comments (Top 15) ‚Äì By Date</h2>
                  <div className="max-h-96 overflow-y-auto">
                    {filteredData
                      .filter(row => row.Sentiment === 'POSITIVE')
                      .sort((a, b) => new Date(b["Comment Date_NEW"]) - new Date(a["Comment Date_NEW"]))
                      .slice(0, 15)
                      .map((row, index) => (
                        <div key={index} className="comment-card">
                          <p className="font-bold">üòä {row["Customer Response"]}</p>
                          <p className="comment-details">
                            Store: {row["Store Code"]} | Date: {row["Comment Date_NEW"].toLocaleDateString('en-US')}
                          </p>
                        </div>
                      ))}
                  </div>
                </div>
                <div>
                  <h2 className="chart-title">Negative Comments (Top 15) ‚Äì By Date</h2>
                  <div className="max-h-96 overflow-y-auto">
                    {filteredData
                      .filter(row => row.Sentiment === 'NEGATIVE')
                      .sort((a, b) => new Date(b["Comment Date_NEW"]) - new Date(a["Comment Date_NEW"]))
                      .slice(0, 15)
                      .map((row, index) => (
                        <div key={index} className="comment-card">
                          <p className="font-bold">üò† {row["Customer Response"]}</p>
                          <p className="comment-details">
                            Store: {row["Store Code"]} | Date: {row["Comment Date_NEW"].toLocaleDateString('en-US')}
                          </p>
                        </div>
                      ))}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    // Rendering the component
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Dashboard />);
  </script>
</body>
</html>
